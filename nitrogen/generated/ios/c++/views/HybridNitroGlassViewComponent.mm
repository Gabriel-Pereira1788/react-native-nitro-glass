///
/// HybridNitroGlassViewComponent.mm
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#import "HybridNitroGlassViewComponent.hpp"
#import <memory>
#import <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#import <React/RCTViewComponentView.h>
#import <React/RCTComponentViewFactory.h>
#import <React/UIView+ComponentViewProtocol.h>
#import <NitroModules/NitroDefines.hpp>
#import <UIKit/UIKit.h>

#import "HybridNitroGlassViewSpecSwift.hpp"
#import "NitroGlassView-Swift-Cxx-Umbrella.hpp"

using namespace facebook;
using namespace margelo::nitro::nitroglassview;
using namespace margelo::nitro::nitroglassview::views;

/**
 * Represents the React Native View holder for the Nitro "NitroGlassView" HybridView.
 */
@interface HybridNitroGlassViewComponent: RCTViewComponentView
@end

@implementation HybridNitroGlassViewComponent {
    std::shared_ptr<HybridNitroGlassViewSpecSwift> _hybridView;
    UIVisualEffectView* _effectView;
}

+ (void) load {
    [super load];
    [RCTComponentViewFactory.currentComponentViewFactory registerComponentViewClass:[HybridNitroGlassViewComponent class]];
}

+ (react::ComponentDescriptorProvider) componentDescriptorProvider {
    return react::concreteComponentDescriptorProvider<HybridNitroGlassViewComponentDescriptor>();
}

- (instancetype) init {
    if (self = [super init]) {
        std::shared_ptr<HybridNitroGlassViewSpec> hybridView = NitroGlassView::NitroGlassViewAutolinking::createNitroGlassView();
        _hybridView = std::dynamic_pointer_cast<HybridNitroGlassViewSpecSwift>(hybridView);
        [self updateView];
    }
    return self;
}

- (void) updateView {
    // 1. Get Swift part
    NitroGlassView::HybridNitroGlassViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();
    
    // 2. Get UIView*
    void* viewUnsafe = swiftPart.getView();
    UIView* view = (__bridge_transfer UIView*) viewUnsafe;
    _effectView = (__bridge_transfer UIVisualEffectView*) viewUnsafe;
    
    // 3. Update RCTViewComponentView's [contentView]
    [self setContentView:view];
}

- (void)layoutSubviews {
    [super layoutSubviews];
    _effectView.layer.cornerRadius = self.layer.cornerRadius;
    _effectView.layer.cornerCurve = self.layer.cornerCurve;
}


- (void)mountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index {
    [_effectView.contentView insertSubview:childComponentView atIndex:index];
}

- (void)unmountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index {
    [childComponentView removeFromSuperview];
}

- (void) updateProps:(const std::shared_ptr<const react::Props>&)props
            oldProps:(const std::shared_ptr<const react::Props>&)oldProps {
    // 1. Downcast props
    const auto& newViewPropsConst = *std::static_pointer_cast<HybridNitroGlassViewProps const>(props);
    auto& newViewProps = const_cast<HybridNitroGlassViewProps&>(newViewPropsConst);
    NitroGlassView::HybridNitroGlassViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();
    
    // 2. Update each prop individually
    swiftPart.beforeUpdate();
    
    // interactive: boolean
    if (newViewProps.interactive.isDirty) {
        swiftPart.setInteractive(newViewProps.interactive.value);
        newViewProps.interactive.isDirty = false;
    }
    // tintColor: optional
    if (newViewProps.tintColor.isDirty) {
        swiftPart.setTintColor(newViewProps.tintColor.value);
        newViewProps.tintColor.isDirty = false;
    }
    // effect: enum
    if (newViewProps.effect.isDirty) {
        swiftPart.setEffect(static_cast<int>(newViewProps.effect.value));
        newViewProps.effect.isDirty = false;
    }
    
    swiftPart.afterUpdate();
    
    // 3. Update hybridRef if it changed
    if (newViewProps.hybridRef.isDirty) {
        // hybridRef changed - call it with new this
        const auto& maybeFunc = newViewProps.hybridRef.value;
        if (maybeFunc.has_value()) {
            maybeFunc.value()(_hybridView);
        }
        newViewProps.hybridRef.isDirty = false;
    }
    
    // 4. Continue in base class
    [super updateProps:props oldProps:oldProps];
}

@end
